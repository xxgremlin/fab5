From 342d51127c33b38d95605eecb824089fb85f831e Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 19:43:49 -0500
Subject: [PATCH 01/23] Add touch-gestures to open up Steam menus

---
 src/main.cpp     |  5 +++++
 src/wlserver.cpp | 28 ++++++++++++++++++++++++++++
 src/wlserver.hpp |  1 +
 3 files changed, 34 insertions(+)

diff --git a/src/main.cpp b/src/main.cpp
index c074f82..a39922c 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -110,6 +110,8 @@ const struct option *gamescope_options = (struct option[]){
 
 	// wlserver options
 	{ "xwayland-count", required_argument, nullptr, 0 },
+	{ "touch-gestures", no_argument, nullptr, 0 },
+
 
 	// steamcompmgr options
 	{ "cursor", required_argument, nullptr, 0 },
@@ -187,6 +189,7 @@ const char usage[] =
 	"  -T, --stats-path               write statistics to path\n"
 	"  -C, --hide-cursor-delay        hide cursor image after delay\n"
 	"  -e, --steam                    enable Steam integration\n"
+	"  --touch-gestures               enable touch gestures for Steam menus\n"
 	"  --xwayland-count               create N xwayland servers\n"
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
@@ -736,6 +739,8 @@ int main(int argc, char **argv)
 					g_bDebugLayers = true;
 				} else if (strcmp(opt_name, "disable-color-management") == 0) {
 					g_bForceDisableColorMgmt = true;
+				} else if (strcmp(opt_name, "touch-gestures") == 0) {
+					cv_touch_gestures = true;
 				} else if (strcmp(opt_name, "xwayland-count") == 0) {
 					g_nXWaylandCount = atoi( optarg );
 				} else if (strcmp(opt_name, "composite-debug") == 0) {
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 78a86ee..ceeef24 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -82,6 +82,7 @@ using namespace std::literals;
 extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
+gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
 
 struct wlserver_t wlserver = {
 	.touch_down_ids = {}
@@ -2537,6 +2538,33 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 
 			if ( bAlwaysWarpCursor )
 				wlserver_mousewarp( tx, ty, time, false );
+
+			if (cv_touch_gestures) {
+				bool start_gesture = false;
+
+				// Round the x-coordinate to the nearest whole number
+				uint32_t roundedCursorX = static_cast<int>(std::round(tx));
+				// Grab 2% of the display to be used for the edge range
+				uint32_t edge_range = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+
+				// Determine if the gesture should start
+				if (roundedCursorX <= edge_range || roundedCursorX >= g_nOutputWidth - edge_range) {
+					start_gesture = true;
+				}
+
+				// Handle Home gesture
+				if (start_gesture && roundedCursorX >= edge_range) {
+					wlserver_open_steam_menu(0);
+					start_gesture = false;
+				}
+
+				// Handle QAM gesture
+				if (start_gesture && roundedCursorX >= g_nOutputWidth - edge_range && roundedCursorX <= g_nOutputWidth) {
+					wlserver_open_steam_menu(1);
+					start_gesture = false;
+				}
+			}
+
 		}
 		else if ( eMode == gamescope::TouchClickModes::Disabled )
 		{
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 0569472..3304c18 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -272,6 +272,7 @@ void wlserver_x11_surface_info_finish( struct wlserver_x11_surface_info *surf );
 void wlserver_set_xwayland_server_mode( size_t idx, int w, int h, int refresh );
 
 extern std::atomic<bool> g_bPendingTouchMovement;
+extern gamescope::ConVar<bool> cv_touch_gestures;
 
 void wlserver_open_steam_menu( bool qam );
 
-- 
2.46.2


From 438d40cbd225a6a2ca7c66e6ac6be2ef0a238a62 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 20:16:20 -0500
Subject: [PATCH 02/23] Add bypass_steam_resolution to workaround the 720p/800p
 restrictions Steam has for games

---
 src/main.cpp         |  3 +++
 src/steamcompmgr.cpp | 11 +++++++++++
 2 files changed, 14 insertions(+)

diff --git a/src/main.cpp b/src/main.cpp
index a39922c..503f837 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -131,6 +131,8 @@ const struct option *gamescope_options = (struct option[]){
 	{ "fade-out-duration", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
+	{ "bypass-steam-resolution", no_argument, nullptr, 0 },
+
 
 	{ "disable-color-management", no_argument, nullptr, 0 },
 	{ "sdr-gamut-wideness", required_argument, nullptr, 0 },
@@ -189,6 +191,7 @@ const char usage[] =
 	"  -T, --stats-path               write statistics to path\n"
 	"  -C, --hide-cursor-delay        hide cursor image after delay\n"
 	"  -e, --steam                    enable Steam integration\n"
+	"  --bypass-steam-resolution      bypass Steam's default 720p/800p default resolution\n"
 	"  --touch-gestures               enable touch gestures for Steam menus\n"
 	"  --xwayland-count               create N xwayland servers\n"
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 11a7cad..2e0e297 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -359,6 +359,8 @@ bool g_bForceHDR10OutputDebug = false;
 gamescope::ConVar<bool> cv_hdr_enabled{ "hdr_enabled", false, "Whether or not HDR is enabled if it is available." };
 bool g_bHDRItmEnable = false;
 int g_nCurrentRefreshRate_CachedValue = 0;
+gamescope::ConVar<bool> cv_bypass_steam_resolution{ "bypass_steam_resolution", false, "Workaround the 720p/800p limits Steam uses for games" };
+
 
 static void
 update_color_mgmt()
@@ -5430,6 +5432,13 @@ handle_property_notify(xwayland_ctx_t *ctx, XPropertyEvent *ev)
 			size_t server_idx = size_t{ xwayland_mode_ctl[ 0 ] };
 			int width = xwayland_mode_ctl[ 1 ];
 			int height = xwayland_mode_ctl[ 2 ];
+
+			if ( g_nOutputWidth != 1280 && width == 1280 && cv_bypass_steam_resolution )
+			{
+				width = g_nOutputWidth;
+				height = g_nOutputHeight;
+			}
+
 			bool allowSuperRes = !!xwayland_mode_ctl[ 3 ];
 
 			if ( !allowSuperRes )
@@ -7445,6 +7454,8 @@ steamcompmgr_main(int argc, char **argv)
 					bForceWindowsFullscreen = true;
 				} else if (strcmp(opt_name, "hdr-enabled") == 0 || strcmp(opt_name, "hdr-enable") == 0) {
 					cv_hdr_enabled = true;
+				} else if (strcmp(opt_name, "bypass_steam_resolution") == 0) {
+					cv_bypass_steam_resolution = true;
 				} else if (strcmp(opt_name, "hdr-debug-force-support") == 0) {
 					g_bForceHDRSupportDebug = true;
  				} else if (strcmp(opt_name, "hdr-debug-force-output") == 0) {
-- 
2.46.2


From 1f40e410d662cd0041764b738067037e45df2192 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Wed, 26 Jul 2023 20:46:29 -0500
Subject: [PATCH 03/23] Add force external orientation.

Co-authored-by: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
---
 src/Backends/DRMBackend.cpp |  5 +++++
 src/main.cpp                | 25 ++++++++++++++++++++++++-
 src/main.hpp                |  1 +
 src/wlserver.cpp            | 23 +++++++++++++++++++++++
 4 files changed, 53 insertions(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 3a996af..6bc64fa 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -532,6 +532,7 @@ bool g_bSupportsSyncObjs = false;
 
 extern gamescope::GamescopeModeGeneration g_eGamescopeModeGeneration;
 extern GamescopePanelOrientation g_DesiredInternalOrientation;
+extern GamescopePanelOrientation g_DesiredExternalOrientation;
 
 extern bool g_bForceDisableColorMgmt;
 
@@ -2026,6 +2027,10 @@ namespace gamescope
 		{
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
+		else if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
+		{
+			m_ChosenOrientation = g_DesiredExternalOrientation;
+		}
 		else
 		{
 			if ( this->GetProperties().panel_orientation )
diff --git a/src/main.cpp b/src/main.cpp
index 503f837..1e0b71e 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -130,6 +130,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "disable-xres", no_argument, nullptr, 'x' },
 	{ "fade-out-duration", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
+	{ "force-external-orientation", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
 	{ "bypass-steam-resolution", no_argument, nullptr, 0 },
 
@@ -196,6 +197,7 @@ const char usage[] =
 	"  --xwayland-count               create N xwayland servers\n"
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
+	"  --force-external-orientation   rotate the external display (left, right, normal, upsidedown)\n"
 	"  --force-windows-fullscreen     force windows inside of gamescope to be the size of the nested display (fullscreen)\n"
 	"  --cursor-scale-height          if specified, sets a base output height to linearly scale the cursor against.\n"
 	"  --hdr-enabled                  enable HDR output (needs Gamescope WSI layer enabled for support from clients)\n"
@@ -291,6 +293,8 @@ bool g_bOutputHDREnabled = false;
 bool g_bFullscreen = false;
 bool g_bForceRelativeMouse = false;
 
+bool g_bExternalForced = false;
+
 bool g_bGrabbed = false;
 
 float g_mouseSensitivity = 1.0;
@@ -364,7 +368,24 @@ static GamescopePanelOrientation force_orientation(const char *str)
 	} else if (strcmp(str, "upsidedown") == 0) {
 		return GAMESCOPE_PANEL_ORIENTATION_180;
 	} else {
-		fprintf( stderr, "gamescope: invalid value for --force-orientation\n" );
+		fprintf( stderr, "gamescope: invalid value for given for --force-orientation\n" );
+		exit(1);
+	}
+}
+
+GamescopePanelOrientation g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_AUTO;
+static GamescopePanelOrientation force_external_orientation(const char *str)
+{
+	if (strcmp(str, "normal") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_0;
+	} else if (strcmp(str, "right") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_270;
+	} else if (strcmp(str, "left") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_90;
+	} else if (strcmp(str, "upsidedown") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_180;
+	} else {
+		fprintf( stderr, "gamescope: invalid value for --force-external-orientation\n" );
 		exit(1);
 	}
 }
@@ -757,6 +778,8 @@ int main(int argc, char **argv)
 					g_eGamescopeModeGeneration = parse_gamescope_mode_generation( optarg );
 				} else if (strcmp(opt_name, "force-orientation") == 0) {
 					g_DesiredInternalOrientation = force_orientation( optarg );
+				} else if (strcmp(opt_name, "force-external-orientation") == 0) {
+					g_DesiredExternalOrientation = force_external_orientation( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscaleFilterSharpness = atoi( optarg );
diff --git a/src/main.hpp b/src/main.hpp
index 2e6fb83..ebd018a 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -28,6 +28,7 @@ extern bool g_bGrabbed;
 
 extern float g_mouseSensitivity;
 extern const char *g_sOutputName;
+extern bool g_bExternalForced;
 
 enum class GamescopeUpscaleFilter : uint32_t
 {
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index ceeef24..62876c2 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2499,6 +2499,29 @@ static void apply_touchscreen_orientation(double *x, double *y )
 			break;
 	}
 
+	// Rotate screen if it's forced with --force-external-orientation
+	switch ( GetBackend()->GetConnector( gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )->GetCurrentOrientation() )
+	{
+		default:
+		case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+		case GAMESCOPE_PANEL_ORIENTATION_0:
+			tx = *x;
+			ty = *y;
+			break;
+		case GAMESCOPE_PANEL_ORIENTATION_90:
+			tx = 1.0 - *y;
+			ty = *x;
+			break;
+		case GAMESCOPE_PANEL_ORIENTATION_180:
+			tx = 1.0 - *x;
+			ty = 1.0 - *y;
+			break;
+		case GAMESCOPE_PANEL_ORIENTATION_270:
+			tx = *y;
+			ty = 1.0 - *x;
+			break;
+	}
+
 	*x = tx;
 	*y = ty;
 }
-- 
2.46.2


From 5ecd89b45675fd4f648a454884db2f970e17894f Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Tue, 12 Mar 2024 00:07:57 +0100
Subject: [PATCH 04/23] implement force-panel-type

---
 src/backend.h          |  3 +++
 src/gamescope_shared.h |  1 +
 src/main.cpp           | 16 ++++++++++++++++
 3 files changed, 20 insertions(+)

diff --git a/src/backend.h b/src/backend.h
index dd295f4..71c41a7 100644
--- a/src/backend.h
+++ b/src/backend.h
@@ -20,6 +20,7 @@ struct wlr_buffer;
 struct wlr_dmabuf_attributes;
 
 struct FrameInfo_t;
+extern gamescope::GamescopeScreenType g_ForcedScreenType;
 
 namespace gamescope
 {
@@ -228,6 +229,8 @@ namespace gamescope
         // Dumb helper we should remove to support multi display someday.
         gamescope::GamescopeScreenType GetScreenType()
         {
+            if (g_ForcedScreenType != GAMESCOPE_SCREEN_TYPE_AUTO)
+                return g_ForcedScreenType;
             if ( GetCurrentConnector() )
                 return GetCurrentConnector()->GetScreenType();
 
diff --git a/src/gamescope_shared.h b/src/gamescope_shared.h
index 1ff54bd..feffdc1 100644
--- a/src/gamescope_shared.h
+++ b/src/gamescope_shared.h
@@ -16,6 +16,7 @@ namespace gamescope
 	{
 		GAMESCOPE_SCREEN_TYPE_INTERNAL,
 		GAMESCOPE_SCREEN_TYPE_EXTERNAL,
+		GAMESCOPE_SCREEN_TYPE_AUTO,
 
 		GAMESCOPE_SCREEN_TYPE_COUNT
 	};
diff --git a/src/main.cpp b/src/main.cpp
index 1e0b71e..967d402 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -131,6 +131,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "fade-out-duration", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
 	{ "force-external-orientation", required_argument, nullptr, 0 },
+	{ "force-panel-type", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
 	{ "bypass-steam-resolution", no_argument, nullptr, 0 },
 
@@ -198,6 +199,7 @@ const char usage[] =
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
 	"  --force-external-orientation   rotate the external display (left, right, normal, upsidedown)\n"
+	"  --force-panel-type             force gamescope to treat the display as either internal or external\n"
 	"  --force-windows-fullscreen     force windows inside of gamescope to be the size of the nested display (fullscreen)\n"
 	"  --cursor-scale-height          if specified, sets a base output height to linearly scale the cursor against.\n"
 	"  --hdr-enabled                  enable HDR output (needs Gamescope WSI layer enabled for support from clients)\n"
@@ -389,6 +391,18 @@ static GamescopePanelOrientation force_external_orientation(const char *str)
 		exit(1);
 	}
 }
+gamescope::GamescopeScreenType g_ForcedScreenType = gamescope::GAMESCOPE_SCREEN_TYPE_AUTO;
+static gamescope::GamescopeScreenType force_panel_type(const char *str)
+{
+	if (strcmp(str, "internal") == 0) {
+		return gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL;
+	} else if (strcmp(str, "external") == 0) {
+		return gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL;
+	} else {
+		fprintf( stderr, "gamescope: invalid value for --force-panel-type\n" );
+		exit(1);
+	}
+}
 
 static enum GamescopeUpscaleScaler parse_upscaler_scaler(const char *str)
 {
@@ -780,6 +794,8 @@ int main(int argc, char **argv)
 					g_DesiredInternalOrientation = force_orientation( optarg );
 				} else if (strcmp(opt_name, "force-external-orientation") == 0) {
 					g_DesiredExternalOrientation = force_external_orientation( optarg );
+				} else if (strcmp(opt_name, "force-panel-type") == 0) {
+					g_ForcedScreenType = force_panel_type( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscaleFilterSharpness = atoi( optarg );
-- 
2.46.2


From 9f4fe80258fdb8405a02bf35ea2d849c32c8baa0 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 21:11:34 -0500
Subject: [PATCH 05/23] wlserver: Fix an issue that would cause gamescope to
 crash when the touchscreen was used

---
 src/wlserver.cpp | 23 -----------------------
 1 file changed, 23 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 62876c2..ceeef24 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2499,29 +2499,6 @@ static void apply_touchscreen_orientation(double *x, double *y )
 			break;
 	}
 
-	// Rotate screen if it's forced with --force-external-orientation
-	switch ( GetBackend()->GetConnector( gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )->GetCurrentOrientation() )
-	{
-		default:
-		case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-		case GAMESCOPE_PANEL_ORIENTATION_0:
-			tx = *x;
-			ty = *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_90:
-			tx = 1.0 - *y;
-			ty = *x;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_180:
-			tx = 1.0 - *x;
-			ty = 1.0 - *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_270:
-			tx = *y;
-			ty = 1.0 - *x;
-			break;
-	}
-
 	*x = tx;
 	*y = ty;
 }
-- 
2.46.2


From 295762788cd549879f700527bdda8a2f1cdab829 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 21:56:55 -0500
Subject: [PATCH 06/23] Add --custom-refresh-rates

---
 src/Backends/DRMBackend.cpp |  3 +++
 src/main.cpp                | 30 ++++++++++++++++++++++++++++++
 src/main.hpp                |  2 ++
 3 files changed, 35 insertions(+)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 6bc64fa..8fffcb7 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2224,6 +2224,9 @@ namespace gamescope
 
 					bHasKnownHDRInfo = true;
 				}
+			} else if ( g_customRefreshRates.size() > 0 ) {
+				m_Mutable.ValidDynamicRefreshRates = g_customRefreshRates;
+				return;
 			}
 		}
 
diff --git a/src/main.cpp b/src/main.cpp
index 967d402..a227936 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -134,6 +134,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "force-panel-type", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
 	{ "bypass-steam-resolution", no_argument, nullptr, 0 },
+	{ "custom-refresh-rates", required_argument, nullptr, 0 },
 
 
 	{ "disable-color-management", no_argument, nullptr, 0 },
@@ -212,6 +213,7 @@ const char usage[] =
 	"  --hdr-itm-target-nits          set the target luminace of the inverse tone mapping process.\n"
 	"                                 Default: 1000 nits, Max: 10000 nits\n"
 	"  --framerate-limit              Set a simple framerate limit. Used as a divisor of the refresh rate, rounds down eg 60 / 59 -> 60fps, 60 / 25 -> 30fps. Default: 0, disabled.\n"
+	"  --custom-refresh-rates         Set custom refresh rates for the output. eg: 60,90,110-120\n"
 	"  --mangoapp                     Launch with the mangoapp (mangohud) performance overlay enabled. You should use this instead of using mangohud on the game or gamescope.\n"
 	"\n"
 	"Nested mode options:\n"
@@ -464,6 +466,32 @@ static enum gamescope::GamescopeBackend parse_backend_name(const char *str)
 		fprintf( stderr, "gamescope: invalid value for --backend\n" );
 		exit(1);
 	}
+
+std::vector<uint32_t> g_customRefreshRates;
+// eg: 60,60,90,110-120
+static std::vector<uint32_t> parse_custom_refresh_rates( const char *str )
+{
+	std::vector<uint32_t> rates;
+	char *token = strtok( strdup(str), ",");
+	while (token)
+	{
+		char *dash = strchr(token, '-');
+		if (dash)
+		{
+			uint32_t start = atoi(token);
+			uint32_t end = atoi(dash + 1);
+			for (uint32_t i = start; i <= end; i++)
+			{
+				rates.push_back(i);
+			}
+		}
+		else
+		{
+			rates.push_back(atoi(token));
+		}
+		token = strtok(nullptr, ",");
+	}
+	return rates;
 }
 
 struct sigaction handle_signal_action = {};
@@ -796,6 +824,8 @@ int main(int argc, char **argv)
 					g_DesiredExternalOrientation = force_external_orientation( optarg );
 				} else if (strcmp(opt_name, "force-panel-type") == 0) {
 					g_ForcedScreenType = force_panel_type( optarg );
+				} else if (strcmp(opt_name, "custom-refresh-rates") == 0) {
+					g_customRefreshRates = parse_custom_refresh_rates( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscaleFilterSharpness = atoi( optarg );
diff --git a/src/main.hpp b/src/main.hpp
index ebd018a..4e09e3b 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -3,6 +3,7 @@
 #include <getopt.h>
 
 #include <atomic>
+#include <vector>
 
 extern const char *gamescope_optstring;
 extern const struct option *gamescope_options;
@@ -29,6 +30,7 @@ extern bool g_bGrabbed;
 extern float g_mouseSensitivity;
 extern const char *g_sOutputName;
 extern bool g_bExternalForced;
+extern std::vector<uint32_t> g_customRefreshRates;
 
 enum class GamescopeUpscaleFilter : uint32_t
 {
-- 
2.46.2


From db836efe685a72571f2df1ad2ce0f00055220206 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 08:44:38 -0500
Subject: [PATCH 07/23] Add rotation gamescope_control command

---
 protocol/gamescope-control.xml | 18 ++++++++++++
 src/Backends/DRMBackend.cpp    | 24 ++++++++++++++--
 src/gamescope_shared.h         | 10 +++++++
 src/main.cpp                   |  1 +
 src/wlserver.cpp               | 50 ++++++++++++++++++++++++++++++++++
 5 files changed, 101 insertions(+), 2 deletions(-)

diff --git a/protocol/gamescope-control.xml b/protocol/gamescope-control.xml
index 012c48c..eab8a84 100644
--- a/protocol/gamescope-control.xml
+++ b/protocol/gamescope-control.xml
@@ -99,5 +99,23 @@
       <arg name="path" type="string" summary="Path to written screenshot"></arg>
     </event>
 
+
+    <enum name="display_rotation_flag" bitfield="true" since="2">
+      <entry name="normal" value="1"/>
+      <entry name="left" value="2"/>
+      <entry name="right" value="3"/>
+      <entry name="upsidedown" value="4"/>
+    </enum>
+
+    <enum name="display_target_type" since="2">
+      <entry name="internal" value="1"/>
+      <entry name="external" value="2"/>
+    </enum>
+
+    <request name="rotate_display" since="2">
+      <arg name="orientation" type="uint" enum="display_rotation_flag" summary="Set the orientation of the display output."/>
+      <arg name="target_type" type="uint" enum="display_target_type" summary="Internal (1) or External (2) target type."/>
+    </request>
+
   </interface>
 </protocol>
diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 8fffcb7..47b8323 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2023,7 +2023,9 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
+		if ( this->GetScreenType() == ( GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
+										|| ( GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+											&& g_bExternalForced ) )
 		{
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
@@ -2959,8 +2961,26 @@ bool drm_update_color_mgmt(struct drm_t *drm)
 	return true;
 }
 
-int g_nDynamicRefreshHz = 0;
+void drm_set_orientation( struct drm_t *drm, bool isRotated)
+{
+	int width = g_nOutputWidth;
+	int height = g_nOutputHeight;
+	g_bRotated = isRotated;
+	if ( g_bRotated ) {
+		int tmp = width;
+		width = height;
+		height = tmp;
+	}
 
+	if (!drm->pConnector || !drm->pConnector->GetModeConnector())
+		return;
+
+	drmModeConnector *connector = drm->pConnector->GetModeConnector();
+	const drmModeModeInfo *mode = find_mode(connector, width, height, 0);
+	update_drm_effective_orientations(drm, mode);
+}
+
+int g_nDynamicRefreshHz = 0;
 static void drm_unset_mode( struct drm_t *drm )
 {
 	drm->pending.mode_id = 0;
diff --git a/src/gamescope_shared.h b/src/gamescope_shared.h
index feffdc1..6e6b7db 100644
--- a/src/gamescope_shared.h
+++ b/src/gamescope_shared.h
@@ -56,6 +56,16 @@ enum GamescopePanelOrientation
 	GAMESCOPE_PANEL_ORIENTATION_AUTO,
 };
 
+enum GamescopePanelExternalOrientation
+{
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_0,   // normal
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_270, // right
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_90,  // left
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_180, // upside down
+
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_AUTO,
+};
+
 // Disable partial composition for now until we get
 // composite priorities working in libliftoff + also
 // use the proper libliftoff composite plane system.
diff --git a/src/main.cpp b/src/main.cpp
index a227936..36421bb 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -399,6 +399,7 @@ static gamescope::GamescopeScreenType force_panel_type(const char *str)
 	if (strcmp(str, "internal") == 0) {
 		return gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL;
 	} else if (strcmp(str, "external") == 0) {
+		g_bExternalForced = true;
 		return gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL;
 	} else {
 		fprintf( stderr, "gamescope: invalid value for --force-panel-type\n" );
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index ceeef24..e386765 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -1043,6 +1043,55 @@ static void gamescope_control_take_screenshot( struct wl_client *client, struct
 	} );
 }
 
+static void gamescope_control_rotate_display( struct wl_client *client, struct wl_resource *resource, uint32_t orientation, uint32_t target_type )
+{
+	bool isRotated = false;
+	if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_INTERNAL )
+	{
+		switch (orientation) {
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+			break;
+		default:
+			wl_log.errorf("Invalid target orientation selected");
+		}
+	}
+	else if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_EXTERNAL )
+	{
+		switch (orientation) {
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_0;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_90;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_270;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_180;
+			break;
+		default:
+			wl_log.errorf("Invalid target orientation selected");
+		}
+	}
+	//drm_set_orientation(&g_DRM, isRotated);
+	//g_DRM.out_of_date = 2;
+}
+
 static void gamescope_control_handle_destroy( struct wl_client *client, struct wl_resource *resource )
 {
 	wl_resource_destroy( resource );
@@ -1052,6 +1101,7 @@ static const struct gamescope_control_interface gamescope_control_impl = {
 	.destroy = gamescope_control_handle_destroy,
 	.set_app_target_refresh_cycle = gamescope_control_set_app_target_refresh_cycle,
 	.take_screenshot = gamescope_control_take_screenshot,
+	.rotate_display = gamescope_control_rotate_display,
 };
 
 static uint32_t get_conn_display_info_flags()
-- 
2.46.2


From 7767e9b4d2aa1408a458077424d12b86a6390dbf Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 11:54:50 -0500
Subject: [PATCH 08/23] Fix an issue that caused force-panel to not work

---
 protocol/gamescope-control.xml |   1 -
 src/Backends/DRMBackend.cpp    |   3 +
 src/wlserver.cpp               | 145 ++++++++++++++++++++-------------
 3 files changed, 90 insertions(+), 59 deletions(-)

diff --git a/protocol/gamescope-control.xml b/protocol/gamescope-control.xml
index eab8a84..7f5578b 100644
--- a/protocol/gamescope-control.xml
+++ b/protocol/gamescope-control.xml
@@ -99,7 +99,6 @@
       <arg name="path" type="string" summary="Path to written screenshot"></arg>
     </event>
 
-
     <enum name="display_rotation_flag" bitfield="true" since="2">
       <entry name="normal" value="1"/>
       <entry name="left" value="2"/>
diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 47b8323..35ffa73 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -309,6 +309,9 @@ namespace gamescope
 
 		GamescopeScreenType GetScreenType() const override
 		{
+			if ( g_ForcedScreenType != GAMESCOPE_SCREEN_TYPE_AUTO )
+				return g_ForcedScreenType;
+
 			if ( m_pConnector->connector_type == DRM_MODE_CONNECTOR_eDP ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_LVDS ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_DSI )
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index e386765..a3af652 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -83,6 +83,8 @@ extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
 gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
+extern GamescopePanelOrientation g_DesiredInternalOrientation;
+extern GamescopePanelOrientation g_DesiredExternalOrientation;
 
 struct wlserver_t wlserver = {
 	.touch_down_ids = {}
@@ -1049,43 +1051,43 @@ static void gamescope_control_rotate_display( struct wl_client *client, struct w
 	if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_INTERNAL )
 	{
 		switch (orientation) {
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
-			break;
-		default:
-			wl_log.errorf("Invalid target orientation selected");
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+				break;
+			default:
+				wl_log.errorf("Invalid target orientation selected");
 		}
 	}
 	else if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_EXTERNAL )
 	{
 		switch (orientation) {
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_0;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_90;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_270;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_180;
-			break;
-		default:
-			wl_log.errorf("Invalid target orientation selected");
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+				break;
+			default:
+				wl_log.errorf("Invalid target orientation selected");
 		}
 	}
 	//drm_set_orientation(&g_DRM, isRotated);
@@ -2523,34 +2525,61 @@ const std::shared_ptr<wlserver_vk_swapchain_feedback>& wlserver_surface_swapchai
 /* Handle the orientation of the touch inputs */
 static void apply_touchscreen_orientation(double *x, double *y )
 {
-	double tx = 0;
-	double ty = 0;
+    double tx = 0;
+    double ty = 0;
 
-	// Use internal screen always for orientation purposes.
-	switch ( GetBackend()->GetConnector( gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL )->GetCurrentOrientation() )
-	{
-		default:
-		case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-		case GAMESCOPE_PANEL_ORIENTATION_0:
-			tx = *x;
-			ty = *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_90:
-			tx = 1.0 - *y;
-			ty = *x;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_180:
-			tx = 1.0 - *x;
-			ty = 1.0 - *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_270:
-			tx = *y;
-			ty = 1.0 - *x;
-			break;
-	}
+    // Use internal screen always for orientation purposes.
+    if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL || g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
+    {
+        switch ( g_DesiredInternalOrientation )
+        {
+			default:
+			case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+			case GAMESCOPE_PANEL_ORIENTATION_0:
+				tx = *x;
+				ty = *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_90:
+				tx = 1.0 - *y;
+				ty = *x;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_180:
+				tx = 1.0 - *x;
+				ty = 1.0 - *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_270:
+				tx = *y;
+				ty = 1.0 - *x;
+				break;
+        }
+    }
+    else if (g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_AUTO)
+    {
+        switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL)->GetCurrentOrientation())
+        {
+			default:
+			case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+			case GAMESCOPE_PANEL_ORIENTATION_0:
+				tx = *x;
+				ty = *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_90:
+				tx = 1.0 - *y;
+				ty = *x;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_180:
+				tx = 1.0 - *x;
+				ty = 1.0 - *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_270:
+				tx = *y;
+				ty = 1.0 - *x;
+				break;
+        }
+    }
 
-	*x = tx;
-	*y = ty;
+    *x = tx;
+    *y = ty;
 }
 
 void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor )
-- 
2.46.2


From a7e3eafdc7fa8976466cac64c6a354f938deca44 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 13:50:57 -0500
Subject: [PATCH 09/23] Fix an arithmetic error

---
 src/Backends/DRMBackend.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 35ffa73..07f0383 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2026,9 +2026,9 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == ( GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
-										|| ( GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
-											&& g_bExternalForced ) )
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+										|| GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+											&& g_bExternalForced )
 		{
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
-- 
2.46.2


From 4988c24ed337f2782c9bf14239a4471b474c42b0 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 19:04:48 -0500
Subject: [PATCH 10/23] Rework the touch gestures to be more smooth

---
 src/wlserver.cpp | 89 +++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 69 insertions(+), 20 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index a3af652..a240871 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -81,6 +81,8 @@ using namespace std::literals;
 
 extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
+bool pending_gesture = false;
+bool pending_osk = false;
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
 gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
 extern GamescopePanelOrientation g_DesiredInternalOrientation;
@@ -363,6 +365,39 @@ void wlserver_open_steam_menu( bool qam )
 	XTestFakeKeyEvent(server->get_xdisplay(), XKeysymToKeycode( server->get_xdisplay(), XK_Control_L ), False, CurrentTime);
 }
 
+void wlserver_open_steam_osk(bool osk)
+{
+	gamescope_xwayland_server_t *server = wlserver_get_xwayland_server( 0 );
+	if (!server)
+		return;
+
+	uint32_t osk_open = osk;
+
+	if (osk_open)
+	{
+		const char *command = "xdg-open steam://open/keyboard?";
+		int result = system(command);
+		if (result == 0) {
+			printf("Command executed successfully.\n");
+		} else {
+			printf("Error executing command.\n");
+		}
+		pending_osk = false;
+	}
+	else
+	{
+		const char *command = "xdg-open steam://close/keyboard?";
+		int result = system(command);
+		if (result == 0) {
+			printf("Command executed successfully.\n");
+		} else {
+			printf("Error executing command.\n");
+		}
+		pending_osk = false;
+	}
+
+}
+
 static void wlserver_handle_pointer_button(struct wl_listener *listener, void *data)
 {
 	struct wlserver_pointer *pointer = wl_container_of( listener, pointer, button );
@@ -2618,32 +2653,46 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 			if ( bAlwaysWarpCursor )
 				wlserver_mousewarp( tx, ty, time, false );
 
-			if (cv_touch_gestures) {
-				bool start_gesture = false;
-
-				// Round the x-coordinate to the nearest whole number
+			if ( cv_touch_gestures )
+			{
 				uint32_t roundedCursorX = static_cast<int>(std::round(tx));
-				// Grab 2% of the display to be used for the edge range
-				uint32_t edge_range = static_cast<uint32_t>(g_nOutputWidth * 0.02);
-
-				// Determine if the gesture should start
-				if (roundedCursorX <= edge_range || roundedCursorX >= g_nOutputWidth - edge_range) {
-					start_gesture = true;
-				}
-
-				// Handle Home gesture
-				if (start_gesture && roundedCursorX >= edge_range) {
+				uint32_t roundedCursorY = static_cast<int>(std::round(ty));
+				uint32_t edge_range_x = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+				uint32_t edge_range_y = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+				uint32_t gesture_limits_x = edge_range_x * 2;
+				uint32_t gesture_limits_y = edge_range_y * 2;
+
+				// Left to Right and Right to Left
+				if (!pending_gesture && roundedCursorX >= 1 && roundedCursorX < edge_range_x ||
+						!pending_gesture && roundedCursorX >= g_nOutputWidth - edge_range_x )
+					pending_gesture = true;
+
+				//left
+				if (pending_gesture && roundedCursorX >= edge_range_x && roundedCursorX < gesture_limits_x) {
 					wlserver_open_steam_menu(0);
-					start_gesture = false;
+					pending_gesture = false;
 				}
-
-				// Handle QAM gesture
-				if (start_gesture && roundedCursorX >= g_nOutputWidth - edge_range && roundedCursorX <= g_nOutputWidth) {
+				//right
+				if (pending_gesture && roundedCursorX <= g_nOutputWidth - edge_range_x && roundedCursorX > g_nOutputWidth - gesture_limits_x) {
 					wlserver_open_steam_menu(1);
-					start_gesture = false;
+					pending_gesture = false;
+				}
+				// Top to Bottom and Bottom to Top
+				if (!pending_gesture && roundedCursorY >= 1 && roundedCursorY < edge_range_y ||
+						!pending_gesture && roundedCursorY >= g_nOutputHeight - edge_range_y )
+					pending_gesture = true;
+				// Top
+				if (pending_gesture && roundedCursorY >= edge_range_y && roundedCursorY < gesture_limits_y) {
+					pending_gesture = false;
+					// Top to Bottom function to add
+				}
+				// Bottom
+				if (pending_gesture && !pending_osk && roundedCursorY <= g_nOutputWidth - edge_range_y && roundedCursorY > g_nOutputHeight - gesture_limits_y) {
+					pending_gesture = false;
+					pending_osk = true;
+					//wlserver_open_steam_osk(1);
 				}
 			}
-
 		}
 		else if ( eMode == gamescope::TouchClickModes::Disabled )
 		{
-- 
2.46.2


From de33de84f4cc272d1d2532b9cbb870ac69f9f4c9 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sun, 19 May 2024 08:55:28 -0500
Subject: [PATCH 11/23] Fix a typo for --bypass-steam-resolution

---
 src/steamcompmgr.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 2e0e297..44a086d 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -7454,7 +7454,7 @@ steamcompmgr_main(int argc, char **argv)
 					bForceWindowsFullscreen = true;
 				} else if (strcmp(opt_name, "hdr-enabled") == 0 || strcmp(opt_name, "hdr-enable") == 0) {
 					cv_hdr_enabled = true;
-				} else if (strcmp(opt_name, "bypass_steam_resolution") == 0) {
+				} else if (strcmp(opt_name, "bypass-steam-resolution") == 0) {
 					cv_bypass_steam_resolution = true;
 				} else if (strcmp(opt_name, "hdr-debug-force-support") == 0) {
 					g_bForceHDRSupportDebug = true;
-- 
2.46.2


From b674368352abaadb7c447070d5a6ba7c1c342f81 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sun, 19 May 2024 11:48:52 -0500
Subject: [PATCH 12/23] Handle gesture cases better to prevent unexpected
 behavior

---
 src/wlserver.cpp | 63 +++++++++++++++++++++++++++++++++---------------
 1 file changed, 43 insertions(+), 20 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index a240871..3837c84 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -81,7 +81,8 @@ using namespace std::literals;
 
 extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
-bool pending_gesture = false;
+bool pending_gesture_x = false;
+bool pending_gesture_y = false;
 bool pending_osk = false;
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
 gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
@@ -2617,6 +2618,16 @@ static void apply_touchscreen_orientation(double *x, double *y )
     *y = ty;
 }
 
+void wlserver_gesture_flush()
+{
+	pending_gesture_x = false;
+	pending_gesture_y = false;
+}
+
+// Variables to track the direction of the touch motion
+uint32_t previous_tx = 0;
+uint32_t previous_ty = 0;
+
 void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor )
 {
 	assert( wlserver_is_lock_held() );
@@ -2655,43 +2666,55 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 
 			if ( cv_touch_gestures )
 			{
-				uint32_t roundedCursorX = static_cast<int>(std::round(tx));
-				uint32_t roundedCursorY = static_cast<int>(std::round(ty));
-				uint32_t edge_range_x = static_cast<uint32_t>(g_nOutputWidth * 0.02);
-				uint32_t edge_range_y = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+				uint32_t rounded_tx = static_cast<int>(std::round(tx));
+				uint32_t rounded_ty = static_cast<int>(std::round(ty));
+				uint32_t edge_range_x = static_cast<uint32_t>(g_nOutputWidth * 0.05);
+				uint32_t edge_range_y = static_cast<uint32_t>(g_nOutputWidth * 0.05);
 				uint32_t gesture_limits_x = edge_range_x * 2;
 				uint32_t gesture_limits_y = edge_range_y * 2;
+				uint32_t threshold_distance_x = gesture_limits_x;
+				uint32_t threshold_distance_y = gesture_limits_y;
 
 				// Left to Right and Right to Left
-				if (!pending_gesture && roundedCursorX >= 1 && roundedCursorX < edge_range_x ||
-						!pending_gesture && roundedCursorX >= g_nOutputWidth - edge_range_x )
-					pending_gesture = true;
+				if (!pending_gesture_x && ((rounded_tx >= 1 && rounded_tx < edge_range_x) || (rounded_tx >= g_nOutputWidth - edge_range_x))) {
+					// Check if the distance moved is greater than the threshold
+					if (rounded_tx - previous_tx > threshold_distance_x) {
+						pending_gesture_x = true;
+					}
+				}
+
+				// Top to Bottom and Bottom to Top
+				if (!pending_gesture_y && ((rounded_ty >= 1 && rounded_ty < edge_range_y) || (rounded_ty >= g_nOutputHeight - edge_range_y))) {
+					// Check if the distance moved is greater than the threshold
+					if (rounded_ty - previous_ty > threshold_distance_y) {
+						pending_gesture_y = true;
+					}
+				}
 
 				//left
-				if (pending_gesture && roundedCursorX >= edge_range_x && roundedCursorX < gesture_limits_x) {
+				if (pending_gesture_x && previous_tx < rounded_tx && rounded_tx >= edge_range_x && rounded_tx < gesture_limits_x) {
 					wlserver_open_steam_menu(0);
-					pending_gesture = false;
+					wlserver_gesture_flush();
 				}
 				//right
-				if (pending_gesture && roundedCursorX <= g_nOutputWidth - edge_range_x && roundedCursorX > g_nOutputWidth - gesture_limits_x) {
+				if (pending_gesture_x && previous_tx > rounded_tx && rounded_tx <= g_nOutputWidth - edge_range_x && rounded_tx > g_nOutputWidth - gesture_limits_x) {
 					wlserver_open_steam_menu(1);
-					pending_gesture = false;
+					wlserver_gesture_flush();
 				}
-				// Top to Bottom and Bottom to Top
-				if (!pending_gesture && roundedCursorY >= 1 && roundedCursorY < edge_range_y ||
-						!pending_gesture && roundedCursorY >= g_nOutputHeight - edge_range_y )
-					pending_gesture = true;
+
 				// Top
-				if (pending_gesture && roundedCursorY >= edge_range_y && roundedCursorY < gesture_limits_y) {
-					pending_gesture = false;
+				if (pending_gesture_y && previous_ty < rounded_ty && rounded_ty >= edge_range_y && rounded_ty < gesture_limits_y) {
+					wlserver_gesture_flush();
 					// Top to Bottom function to add
 				}
 				// Bottom
-				if (pending_gesture && !pending_osk && roundedCursorY <= g_nOutputWidth - edge_range_y && roundedCursorY > g_nOutputHeight - gesture_limits_y) {
-					pending_gesture = false;
+				if (pending_gesture_y && previous_ty > rounded_ty && !pending_osk && rounded_ty <= g_nOutputWidth - edge_range_y && rounded_ty > g_nOutputHeight - gesture_limits_y) {
+					wlserver_gesture_flush();
 					pending_osk = true;
 					//wlserver_open_steam_osk(1);
 				}
+				previous_tx = rounded_tx;
+				previous_ty = rounded_ty;
 			}
 		}
 		else if ( eMode == gamescope::TouchClickModes::Disabled )
-- 
2.46.2


From c672cac17d538df286efaee9f29d289a71e13383 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sun, 19 May 2024 18:14:23 -0500
Subject: [PATCH 13/23] Add references to drm_set_orientation() and g_drm in
 wlserver for rotation gamescope-control

---
 src/wlserver.cpp | 5 +++--
 src/wlserver.hpp | 3 ++-
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 3837c84..13ea8b5 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -1126,8 +1126,9 @@ static void gamescope_control_rotate_display( struct wl_client *client, struct w
 				wl_log.errorf("Invalid target orientation selected");
 		}
 	}
-	//drm_set_orientation(&g_DRM, isRotated);
-	//g_DRM.out_of_date = 2;
+	drm_set_orientation(&g_DRM, isRotated);
+	GetBackend()->DirtyState( true, true );
+
 }
 
 static void gamescope_control_handle_destroy( struct wl_client *client, struct wl_resource *resource )
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 3304c18..0754ee5 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -275,7 +275,8 @@ extern std::atomic<bool> g_bPendingTouchMovement;
 extern gamescope::ConVar<bool> cv_touch_gestures;
 
 void wlserver_open_steam_menu( bool qam );
-
+extern void drm_set_orientation( struct drm_t *drm, bool isRotated);
+extern drm_t g_DRM;
 uint32_t wlserver_make_new_xwayland_server();
 void wlserver_destroy_xwayland_server(gamescope_xwayland_server_t *server);
 
-- 
2.46.2


From b7b08665aaf344cd9930069e52931335daafaddb Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 07:02:52 -0500
Subject: [PATCH 14/23] Fix an issue where forced panel type orientations
 weren't being applied

---
 src/Backends/DRMBackend.cpp | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 07f0383..8200619 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2026,20 +2026,19 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
-										|| GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
-											&& g_bExternalForced )
-		{
+		if ((this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) ||
+			(this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO && g_bExternalForced)) {
+			drm_log.infof("We are rotating the orientation of the internal or faked external display")
 			m_ChosenOrientation = g_DesiredInternalOrientation;
-		}
-		else if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
-		{
+		} else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
+			drm_log.infof("We are rotating the orientation of an external display");
 			m_ChosenOrientation = g_DesiredExternalOrientation;
 		}
 		else
 		{
 			if ( this->GetProperties().panel_orientation )
 			{
+				drm_log.infof("We are using a kernel orientation quirk to rotate the display");
 				switch ( this->GetProperties().panel_orientation->GetCurrentValue() )
 				{
 					case DRM_MODE_PANEL_ORIENTATION_NORMAL:
@@ -2061,6 +2060,7 @@ namespace gamescope
 
 			if ( this->GetScreenType() == gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL && pMode )
 			{
+				drm_log.infof("We are using legacy code to rotate the display");
 				// Auto-detect portait mode for internal displays
 				m_ChosenOrientation = pMode->hdisplay < pMode->vdisplay
 					? GAMESCOPE_PANEL_ORIENTATION_270
@@ -2068,6 +2068,7 @@ namespace gamescope
 			}
 			else
 			{
+				drm_log.infof("No orientation quirks have been applied");
 				m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
 			}
 		}
-- 
2.46.2


From a98358aafc43480b3373030ef6d39c5342df5394 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 07:25:29 -0500
Subject: [PATCH 15/23] add missing curly bracket...

---
 src/Backends/DRMBackend.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 8200619..10b9b92 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2028,7 +2028,7 @@ namespace gamescope
 	{
 		if ((this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) ||
 			(this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO && g_bExternalForced)) {
-			drm_log.infof("We are rotating the orientation of the internal or faked external display")
+			drm_log.infof("We are rotating the orientation of the internal or faked external display");
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		} else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
 			drm_log.infof("We are rotating the orientation of an external display");
-- 
2.46.2


From 28fa8b1b2b61beb37e60149f4eeac2b12eeb5d59 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 10:17:55 -0500
Subject: [PATCH 16/23] Fix case where real externals were rotated with faked
 external panels

---
 src/Backends/DRMBackend.cpp | 21 +++++++----
 src/wlserver.cpp            | 72 +++++++++++++++++++++++++------------
 2 files changed, 64 insertions(+), 29 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 10b9b92..848c71f 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -309,13 +309,20 @@ namespace gamescope
 
 		GamescopeScreenType GetScreenType() const override
 		{
-			if ( g_ForcedScreenType != GAMESCOPE_SCREEN_TYPE_AUTO )
-				return g_ForcedScreenType;
-
 			if ( m_pConnector->connector_type == DRM_MODE_CONNECTOR_eDP ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_LVDS ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_DSI )
-				return GAMESCOPE_SCREEN_TYPE_INTERNAL;
+			{
+				if ( g_bExternalForced )
+				{
+					return g_ForcedScreenType;
+				}
+				else
+				{
+					return GAMESCOPE_SCREEN_TYPE_INTERNAL;
+				}
+			}
+
 
 			return GAMESCOPE_SCREEN_TYPE_EXTERNAL;
 		}
@@ -2026,11 +2033,11 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ((this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) ||
-			(this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO && g_bExternalForced)) {
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO ) {
 			drm_log.infof("We are rotating the orientation of the internal or faked external display");
 			m_ChosenOrientation = g_DesiredInternalOrientation;
-		} else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
+		}
+		else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
 			drm_log.infof("We are rotating the orientation of an external display");
 			m_ChosenOrientation = g_DesiredExternalOrientation;
 		}
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 13ea8b5..8b9201c 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2566,29 +2566,57 @@ static void apply_touchscreen_orientation(double *x, double *y )
     double ty = 0;
 
     // Use internal screen always for orientation purposes.
-    if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL || g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
+    if ( g_ForcedScreenType != gamescope::GAMESCOPE_SCREEN_TYPE_AUTO )
     {
-        switch ( g_DesiredInternalOrientation )
-        {
-			default:
-			case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-			case GAMESCOPE_PANEL_ORIENTATION_0:
-				tx = *x;
-				ty = *y;
-				break;
-			case GAMESCOPE_PANEL_ORIENTATION_90:
-				tx = 1.0 - *y;
-				ty = *x;
-				break;
-			case GAMESCOPE_PANEL_ORIENTATION_180:
-				tx = 1.0 - *x;
-				ty = 1.0 - *y;
-				break;
-			case GAMESCOPE_PANEL_ORIENTATION_270:
-				tx = *y;
-				ty = 1.0 - *x;
-				break;
-        }
+		if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
+		{
+			switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL)->GetCurrentOrientation())
+			{
+				default:
+				case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+				case GAMESCOPE_PANEL_ORIENTATION_0:
+					tx = *x;
+					ty = *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_90:
+					tx = 1.0 - *y;
+					ty = *x;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_180:
+					tx = 1.0 - *x;
+					ty = 1.0 - *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_270:
+					tx = *y;
+					ty = 1.0 - *x;
+					break;
+			}
+		}
+		else
+		{
+			switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL)->GetCurrentOrientation())
+			{
+				default:
+				case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+				case GAMESCOPE_PANEL_ORIENTATION_0:
+					tx = *x;
+					ty = *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_90:
+					tx = 1.0 - *y;
+					ty = *x;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_180:
+					tx = 1.0 - *x;
+					ty = 1.0 - *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_270:
+					tx = *y;
+					ty = 1.0 - *x;
+					break;
+			}
+		}
+
     }
     else if (g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_AUTO)
     {
-- 
2.46.2


From 686be5e1e03f708525755f344fabc24b1e81f3fe Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 16:30:47 -0500
Subject: [PATCH 17/23] Add verbose panel logs and attempt to address all
 orientation issues

---
 src/Backends/DRMBackend.cpp | 18 ++++++++++++++--
 src/wlserver.cpp            | 41 ++++++++++++++++++++-----------------
 src/wlserver.hpp            |  1 +
 3 files changed, 39 insertions(+), 21 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 848c71f..e1b1d48 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -58,6 +58,7 @@ static constexpr bool k_bUseCursorPlane = false;
 
 extern int g_nPreferredOutputWidth;
 extern int g_nPreferredOutputHeight;
+bool panelTypeChanged = false;
 
 gamescope::ConVar<bool> cv_drm_single_plane_optimizations( "drm_single_plane_optimizations", true, "Whether or not to enable optimizations for single plane usage." );
 
@@ -315,6 +316,7 @@ namespace gamescope
 			{
 				if ( g_bExternalForced )
 				{
+					panelTypeChanged = true;
 					return g_ForcedScreenType;
 				}
 				else
@@ -323,7 +325,7 @@ namespace gamescope
 				}
 			}
 
-
+			panelTypeChanged = false;
 			return GAMESCOPE_SCREEN_TYPE_EXTERNAL;
 		}
 
@@ -2033,7 +2035,19 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO ) {
+
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && panelTypeChanged )
+			drm_log.infof("Display is internal faked as external");
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && !panelTypeChanged )
+			drm_log.infof("Display is real internal");
+		if (panelTypeChanged){
+			drm_log.infof("Panel type was changed");
+		}
+
+		if (( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO ) ||
+			( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+			  && panelTypeChanged)) {
+
 			drm_log.infof("We are rotating the orientation of the internal or faked external display");
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 8b9201c..7adf7db 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2570,26 +2570,29 @@ static void apply_touchscreen_orientation(double *x, double *y )
     {
 		if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
 		{
-			switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL)->GetCurrentOrientation())
+			if(panelTypeChanged)
 			{
-				default:
-				case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-				case GAMESCOPE_PANEL_ORIENTATION_0:
-					tx = *x;
-					ty = *y;
-					break;
-				case GAMESCOPE_PANEL_ORIENTATION_90:
-					tx = 1.0 - *y;
-					ty = *x;
-					break;
-				case GAMESCOPE_PANEL_ORIENTATION_180:
-					tx = 1.0 - *x;
-					ty = 1.0 - *y;
-					break;
-				case GAMESCOPE_PANEL_ORIENTATION_270:
-					tx = *y;
-					ty = 1.0 - *x;
-					break;
+				switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL)->GetCurrentOrientation())
+				{
+					default:
+					case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+					case GAMESCOPE_PANEL_ORIENTATION_0:
+						tx = *x;
+						ty = *y;
+						break;
+					case GAMESCOPE_PANEL_ORIENTATION_90:
+						tx = 1.0 - *y;
+						ty = *x;
+						break;
+					case GAMESCOPE_PANEL_ORIENTATION_180:
+						tx = 1.0 - *x;
+						ty = 1.0 - *y;
+						break;
+					case GAMESCOPE_PANEL_ORIENTATION_270:
+						tx = *y;
+						ty = 1.0 - *x;
+						break;
+				}
 			}
 		}
 		else
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 0754ee5..bdf3b0b 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -277,6 +277,7 @@ extern gamescope::ConVar<bool> cv_touch_gestures;
 void wlserver_open_steam_menu( bool qam );
 extern void drm_set_orientation( struct drm_t *drm, bool isRotated);
 extern drm_t g_DRM;
+extern bool panelTypeChanged;
 uint32_t wlserver_make_new_xwayland_server();
 void wlserver_destroy_xwayland_server(gamescope_xwayland_server_t *server);
 
-- 
2.46.2


From 0ca7930d0463e87733aeeebed7c4585c712b27e5 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Tue, 28 May 2024 21:56:47 +0200
Subject: [PATCH 18/23] add closing bracket

---
 src/main.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/main.cpp b/src/main.cpp
index 36421bb..83fc011 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -467,6 +467,7 @@ static enum gamescope::GamescopeBackend parse_backend_name(const char *str)
 		fprintf( stderr, "gamescope: invalid value for --backend\n" );
 		exit(1);
 	}
+}
 
 std::vector<uint32_t> g_customRefreshRates;
 // eg: 60,60,90,110-120
-- 
2.46.2


From 14a226e40efba864cd2b01b258f7cc4e3aedc322 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Wed, 3 Jan 2024 17:03:04 +0100
Subject: [PATCH 19/23] remove hacky texture

This will use more hardware planes, causing some devices to composite yeilding lower framerates
---
 src/steamcompmgr.cpp | 62 ++++++++++++--------------------------------
 1 file changed, 17 insertions(+), 45 deletions(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 44a086d..8b288ab 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -1623,7 +1623,7 @@ bool MouseCursor::getTexture()
 				{
 					pixels[i * image->width + j] = image->pixels[i * image->width + j];
 				}
-			} 
+			}
 			std::vector<uint32_t> resizeBuffer( nDesiredWidth * nDesiredHeight );
 			stbir_resize_uint8_srgb( (unsigned char *)pixels.data(),       image->width,  image->height,  0,
 									 (unsigned char *)resizeBuffer.data(), nDesiredWidth, nDesiredHeight, 0,
@@ -2318,7 +2318,7 @@ paint_all(bool async)
 					}
 				}
 			}
-			
+
 			int nOldLayerCount = frameInfo.layerCount;
 
 			uint32_t flags = 0;
@@ -2326,7 +2326,7 @@ paint_all(bool async)
 				flags |= PaintWindowFlag::BasePlane;
 			paint_window(w, w, &frameInfo, global_focus.cursor, flags);
 			update_touch_scaling( &frameInfo );
-			
+
 			// paint UI unless it's fully hidden, which it communicates to us through opacity=0
 			// we paint it to extract scaling coefficients above, then remove the layer if one was added
 			if ( w->opacity == TRANSLUCENT && bHasVideoUnderlay && nOldLayerCount < frameInfo.layerCount )
@@ -2339,7 +2339,7 @@ paint_all(bool async)
 				float opacityScale = g_bPendingFade
 					? 0.0f
 					: ((currentTime - fadeOutStartTime) / (float)g_FadeOutDuration);
-		
+
 				paint_cached_base_layer(g_HeldCommits[HELD_COMMIT_FADE], g_CachedPlanes[HELD_COMMIT_FADE], &frameInfo, 1.0f - opacityScale, false);
 				paint_window(w, w, &frameInfo, global_focus.cursor, PaintWindowFlag::BasePlane | PaintWindowFlag::FadeTarget | PaintWindowFlag::DrawBorders, opacityScale, override);
 			}
@@ -2413,34 +2413,6 @@ paint_all(bool async)
 		if ( overlay == global_focus.inputFocusWindow )
 			update_touch_scaling( &frameInfo );
 	}
-	else if ( !GetBackend()->UsesVulkanSwapchain() && GetBackend()->IsSessionBased() )
-	{
-		auto tex = vulkan_get_hacky_blank_texture();
-		if ( tex != nullptr )
-		{
-			// HACK! HACK HACK HACK
-			// To avoid stutter when toggling the overlay on 
-			int curLayer = frameInfo.layerCount++;
-
-			FrameInfo_t::Layer_t *layer = &frameInfo.layers[ curLayer ];
-
-
-			layer->scale.x = g_nOutputWidth == tex->width() ? 1.0f : tex->width() / (float)g_nOutputWidth;
-			layer->scale.y = g_nOutputHeight == tex->height() ? 1.0f : tex->height() / (float)g_nOutputHeight;
-			layer->offset.x = 0.0f;
-			layer->offset.y = 0.0f;
-			layer->opacity = 1.0f; // BLAH
-			layer->zpos = g_zposOverlay;
-			layer->applyColorMgmt = g_ColorMgmt.pending.enabled;
-
-			layer->colorspace = GAMESCOPE_APP_TEXTURE_COLORSPACE_LINEAR;
-			layer->ctm = nullptr;
-			layer->tex = tex;
-
-			layer->filter = GamescopeUpscaleFilter::NEAREST;
-			layer->blackBorder = true;
-		}
-	}
 
 	if (notification)
 	{
@@ -3045,7 +3017,7 @@ win_maybe_a_dropdown( steamcompmgr_win_t *w )
 	//
 	// TODO: Come back to me for original Age of Empires HD launcher.
 	// Does that use it? It wants blending!
-	// 
+	//
 	// Only do this if we have CONTROLPARENT right now. Some other apps, such as the
 	// Street Fighter V (310950) Splash Screen also use LAYERED and TOOLWINDOW, and we don't
 	// want that to be overlayed.
@@ -3060,12 +3032,12 @@ win_maybe_a_dropdown( steamcompmgr_win_t *w )
 
 	// Josh:
 	// The logic here is as follows. The window will be treated as a dropdown if:
-	// 
+	//
 	// If this window has a fixed position on the screen + static gravity:
 	//  - If the window has either skipPage or skipTaskbar
 	//    - If the window isn't a dialog, always treat it as a dropdown, as it's
 	//      probably meant to be some form of popup.
-	//    - If the window is a dialog 
+	//    - If the window is a dialog
 	// 		- If the window has transient for, disregard it, as it is trying to redirecting us elsewhere
 	//        ie. a settings menu dialog popup or something.
 	//      - If the window has both skip taskbar and pager, treat it as a dialog.
@@ -3157,7 +3129,7 @@ static bool is_good_override_candidate( steamcompmgr_win_t *override, steamcompm
 		return false;
 
 	return override != focus && override->GetGeometry().nX >= 0 && override->GetGeometry().nY >= 0;
-} 
+}
 
 static bool
 pick_primary_focus_and_override(focus_t *out, Window focusControlWindow, const std::vector<steamcompmgr_win_t*>& vecPossibleFocusWindows, bool globalFocus, const std::vector<uint32_t>& ctxFocusControlAppIDs)
@@ -3298,7 +3270,7 @@ found:;
 
 	if ( focus )
 	{
-		if ( window_has_commits( focus ) ) 
+		if ( window_has_commits( focus ) )
 			out->focusWindow = focus;
 		else
 			focus->outdatedInteractiveFocus = true;
@@ -3341,9 +3313,9 @@ found:;
 					override_focus = fake_override;
 					goto found2;
 				}
-			}	
+			}
 		}
-		
+
 		found2:;
 		resolveTransientOverrides( true );
 	}
@@ -4605,7 +4577,7 @@ finish_destroy_win(xwayland_ctx_t *ctx, Window id, bool gone)
 		{
 			if (gone)
 				finish_unmap_win (ctx, w);
-			
+
 			{
 				std::unique_lock lock( ctx->list_mutex );
 				*prev = w->xwayland().next;
@@ -4662,7 +4634,7 @@ destroy_win(xwayland_ctx_t *ctx, Window id, bool gone, bool fade)
 		global_focus.overrideWindow = nullptr;
 	if (x11_win(global_focus.fadeWindow) == id && gone)
 		global_focus.fadeWindow = nullptr;
-		
+
 	MakeFocusDirty();
 
 	finish_destroy_win(ctx, id, gone);
@@ -5286,7 +5258,7 @@ handle_property_notify(xwayland_ctx_t *ctx, XPropertyEvent *ev)
 		{
 			get_win_type(ctx, w);
 			MakeFocusDirty();
-		}		
+		}
 	}
 	if (ev->atom == ctx->atoms.sizeHintsAtom)
 	{
@@ -6196,7 +6168,7 @@ void handle_done_commits_xdg( bool vblank, uint64_t vblank_idx )
 			commits_before_their_time.push_back( entry );
 			continue;
 		}
-		
+
 		if (!entry.earliestPresentTime)
 		{
 			entry.earliestPresentTime = next_refresh_time;
@@ -7218,7 +7190,7 @@ void update_mode_atoms(xwayland_ctx_t *root_ctx, bool* needs_flush = nullptr)
 	}
 	XChangeProperty(root_ctx->dpy, root_ctx->root, root_ctx->atoms.gamescopeDisplayModeListExternal, XA_STRING, 8, PropModeReplace,
 		(unsigned char *)modes, strlen(modes) + 1 );
-	
+
 	uint32_t one = 1;
 	XChangeProperty(root_ctx->dpy, root_ctx->root, root_ctx->atoms.gamescopeDisplayIsExternal, XA_CARDINAL, 32, PropModeReplace,
 		(unsigned char *)&one, 1 );
@@ -8065,7 +8037,7 @@ void steamcompmgr_send_frame_done_to_focus_window()
 	{
 		wlserver_lock();
 		wlserver_send_frame_done( global_focus.focusWindow->xwayland().surface.main_surface , &now );
-		wlserver_unlock();		
+		wlserver_unlock();
 	}
 }
 
-- 
2.46.2


From e2f4c39992e2fa55f03225019fe244f08f49b287 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joaqu=C3=ADn=20Ignacio=20Aramend=C3=ADa?=
 <samsagax@gmail.com>
Date: Tue, 9 Jul 2024 18:29:16 -0300
Subject: [PATCH 20/23] disable explicit sync to avoid graphical artifacts

---
 src/Backends/DRMBackend.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index e1b1d48..ae5c767 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -70,7 +70,7 @@ gamescope::ConVar<bool> cv_drm_debug_disable_blend_tf( "drm_debug_disable_blend_
 gamescope::ConVar<bool> cv_drm_debug_disable_ctm( "drm_debug_disable_ctm", false, "CTM chicken bit. (Forces CTM off, does not affect other logic)" );
 gamescope::ConVar<bool> cv_drm_debug_disable_color_encoding( "drm_debug_disable_color_encoding", false, "YUV Color Encoding chicken bit. (Forces COLOR_ENCODING to DEFAULT, does not affect other logic)" );
 gamescope::ConVar<bool> cv_drm_debug_disable_color_range( "drm_debug_disable_color_range", false, "YUV Color Range chicken bit. (Forces COLOR_RANGE to DEFAULT, does not affect other logic)" );
-gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync( "drm_debug_disable_explicit_sync", false, "Force disable explicit sync on the DRM backend." );
+gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync( "drm_debug_disable_explicit_sync", true, "Force disable explicit sync on the DRM backend." );
 gamescope::ConVar<bool> cv_drm_debug_disable_in_fence_fd( "drm_debug_disable_in_fence_fd", false, "Force disable IN_FENCE_FD being set to avoid over-synchronization on the DRM backend." );
 
 namespace gamescope
-- 
2.46.2


From 9c77c12061530ff1403ed213c60f060791deb863 Mon Sep 17 00:00:00 2001
From: Kyle Gospodnetich <me@kylegospodneti.ch>
Date: Tue, 2 Jul 2024 14:12:47 -0700
Subject: [PATCH 21/23] Only change refresh rates on internal displays

---
 src/Backends/DRMBackend.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index ae5c767..1fc35e5 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2251,7 +2251,7 @@ namespace gamescope
 
 					bHasKnownHDRInfo = true;
 				}
-			} else if ( g_customRefreshRates.size() > 0 ) {
+			} else if ( g_customRefreshRates.size() > 0 && GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL ) {
 				m_Mutable.ValidDynamicRefreshRates = g_customRefreshRates;
 				return;
 			}
-- 
2.46.2


From f67acb1e222ac04d08acc4480d071a871f188553 Mon Sep 17 00:00:00 2001
From: Kyle Gospodnetich <me@kylegospodneti.ch>
Date: Tue, 2 Jul 2024 15:14:23 -0700
Subject: [PATCH 22/23] Also check g_bExternalForced

---
 src/Backends/DRMBackend.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 1fc35e5..6048a2d 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2251,7 +2251,7 @@ namespace gamescope
 
 					bHasKnownHDRInfo = true;
 				}
-			} else if ( g_customRefreshRates.size() > 0 && GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL ) {
+			} else if ( g_customRefreshRates.size() > 0 && ( GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL || g_bExternalForced ) ) {
 				m_Mutable.ValidDynamicRefreshRates = g_customRefreshRates;
 				return;
 			}
-- 
2.46.2


From 3e9510adf6d246a29fcb0fe5df11bcf1b4299f72 Mon Sep 17 00:00:00 2001
From: Alesh Slovak <alesh@playtron.one>
Date: Thu, 26 Sep 2024 07:13:24 -0400
Subject: [PATCH 23/23] Revert "steamcompmgr: Move outdatedInteractiveFocus to
 window"

This reverts commit 299bc3410dcfd46da5e3c988354b60ed3a356900.
---
 src/steamcompmgr.cpp        | 39 +++++++++++++++++++++++--------------
 src/steamcompmgr_shared.hpp |  1 -
 2 files changed, 24 insertions(+), 16 deletions(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 8b288ab..dcb2c71 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -3273,7 +3273,7 @@ found:;
 		if ( window_has_commits( focus ) )
 			out->focusWindow = focus;
 		else
-			focus->outdatedInteractiveFocus = true;
+			out->outdatedInteractiveFocus = true;
 
 		// Always update X's idea of focus, but still dirty
 		// the it being outdated so we can resolve that globally later.
@@ -6025,28 +6025,37 @@ bool handle_done_commit( steamcompmgr_win_t *w, xwayland_ctx_t *ctx, uint64_t co
 			// Window just got a new available commit, determine if that's worth a repaint
 
 			// If this is an overlay that we're presenting, repaint
-			if ( w == global_focus.overlayWindow && w->opacity != TRANSLUCENT )
+			if ( gameFocused )
 			{
-				hasRepaintNonBasePlane = true;
-			}
+				if ( w == global_focus.overlayWindow && w->opacity != TRANSLUCENT )
+				{
+					hasRepaintNonBasePlane = true;
+				}
 
-			if ( w == global_focus.notificationWindow && w->opacity != TRANSLUCENT )
-			{
-				hasRepaintNonBasePlane = true;
+				if ( w == global_focus.notificationWindow && w->opacity != TRANSLUCENT )
+				{
+					hasRepaintNonBasePlane = true;
+				}
 			}
-
-			// If this is an external overlay, repaint
-			if ( w == global_focus.externalOverlayWindow && w->opacity != TRANSLUCENT )
+			if ( ctx )
 			{
-				hasRepaintNonBasePlane = true;
+				if ( ctx->focus.outdatedInteractiveFocus )
+				{
+					MakeFocusDirty();
+					ctx->focus.outdatedInteractiveFocus = false;
+				}
 			}
-
-			if ( w->outdatedInteractiveFocus )
+			if ( global_focus.outdatedInteractiveFocus )
 			{
 				MakeFocusDirty();
-				w->outdatedInteractiveFocus = false;
-			}
+				global_focus.outdatedInteractiveFocus = false;
 
+				// If this is an external overlay, repaint
+				if ( w == global_focus.externalOverlayWindow && w->opacity != TRANSLUCENT )
+				{
+					hasRepaintNonBasePlane = true;
+				}
+			}
 			// If this is the main plane, repaint
 			if ( w == global_focus.focusWindow && !w->isSteamStreamingClient )
 			{
diff --git a/src/steamcompmgr_shared.hpp b/src/steamcompmgr_shared.hpp
index 095694e..e41fad9 100644
--- a/src/steamcompmgr_shared.hpp
+++ b/src/steamcompmgr_shared.hpp
@@ -125,7 +125,6 @@ struct steamcompmgr_win_t {
 	unsigned int requestedHeight = 0;
 	bool is_dialog = false;
 	bool maybe_a_dropdown = false;
-	bool outdatedInteractiveFocus = false;
 
 	bool hasHwndStyle = false;
 	uint32_t hwndStyle = 0;
-- 
2.46.2

